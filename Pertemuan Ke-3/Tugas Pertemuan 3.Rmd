---
title: "Tugas Pertemuan 3"
author: "Mhd Haekal Hakim"
date: "2025-09-17"
output: html_document
---

# Packages
```{r echo=FALSE}
#PACKAGES
#install.packages("dLagM")
#install.packages("dynlm")
#install.packages("MLmetrics")
library(dLagM)
library(dynlm)
library(MLmetrics)
library(lmtest)
library(car)
library(dplyr)
```

# Import Data
```{r}
data <- read.csv("C:/Users/mhdha/Downloads/NewDelhi_Air_quality.csv")
str(data)
data
```

```{r}
# Mengubah nama variabel agar mudah untuk diolah
names(data)[names(data) == "AQI"] <- "Yt"
names(data)[names(data) == "pm25"]  <- "Xt"

# Menambahkan kolom t untuk periodenya
data$t <- 1:nrow(data)

# Menambahkan kolom Y(t-1)
data[["Y(t-1)"]] <- dplyr::lag(data$Yt)

# Membuat data baru dengan menggunakan variabel pm25 saja sebagai peubah x sesuai dengan perintah soal
data <- data[, c("t", "Yt", "Y(t-1)", "Xt")]
print(data)
```

## Pembagian Data

```{r}
#Split Data untuk data train (80%) dan data test (20%),
train<-data[1:58,]
test<-data[59:72,]
```

```{r}
#data time series
train.ts<-ts(train)
test.ts<-ts(test)
data.ts<-ts(data)
```

-   **distributed lag model** : Variabel Dependen Y dipengaruhi oleh lag dari variabel independen X ( Xt-1, Xt-2 , dst)

-   **Autoregresive model** : Variabel Dependen Y dipengaruhi oleh lag dirinya sendiri (Yt-1, Yt-2, dst) dan X sekarang (Xt)

# Model Koyck

Model Koyck didasarkan pada asumsi bahwa semakin jauh jarak lag peubah independen dari periode sekarang maka semakin kecil pengaruh peubah lag terhadap peubah dependen.

Koyck mengusulkan suatu metode untuk menduga model dinamis distributed lag dengan mengasumsikan bahwa semua koefisien $\beta$ mempunyai tanda sama.

Model kyock merupakan jenis paling umum dari model infinite distributed lag dan juga dikenal sebagai geometric lag

$$
y_t=a(1-\lambda)+\beta_0X_t+\beta_1Z_t+\lambda Y_{t-1}+V_t
$$

dengan $$V_t=u_t-\lambda u_{t-1}$$

## Pemodelan

Pemodelan model Koyck dengan `R` dapat menggunakan `dLagM::koyckDlm()` . Fungsi umum dari `koyckDlm` adalah sebagai berikut.
```{r, eval=FALSE, message = FALSE, warning=FALSE, error=FALSE}
koyckDlm(x , y , intercept)
```

Fungsi `koyckDlm()` akan menerapkan model lag terdistribusi dengan transformasi Koyck satu prediktor. Nilai `x` dan `y` tidak perlu sebagai objek *time series* (`ts`). `intercept` dapat dibuat `TRUE` untuk memasukkan intersep ke dalam model.

```{r}
#MODEL KOYCK menggunakan fungsi koyckDlm()
model.koyck <- koyckDlm(x = train$Xt, y = train$Yt)
summary(model.koyck)
# Menghitung nilai AIC dan BIC untuk mengevaluasi model
AIC(model.koyck) 
BIC(model.koyck)
```

Dari hasil tersebut, didapat bahwa peubah $x_t$ dan $y_{t-1}$ memiliki nilai $P-Value<0.05$. Hal ini menunjukkan bahwa peubah $x_t$ dan $y_{t-1}$ berpengaruh signifikan terhadap $y$. Adapun model keseluruhannya adalah sebagai berikut

$$
\hat{Y_t}=4.0771-0.5723X_t+0.8897Y_{t-1}
$$

## Peramalan dan Akurasi

Berikut adalah hasil peramalan y untuk 14 periode kedepan menggunakan model koyck

```{r}
fore.koyck <- forecast(model = model.koyck, x=test$Xt, h=14)
fore.koyck
mape.koyck <- MAPE(fore.koyck$forecasts, test$Yt)
mape.koyck #data test
#akurasi data training
GoF(model.koyck)
```

# Regression with Distributed Lag

Pemodelan model Regression with Distributed Lag dengan `R` dapat menggunakan `dLagM::dlm()` . Fungsi umum dari `dlm` adalah sebagai berikut.

```{r, eval=FALSE, error=FALSE}
dlm(formula , data , x , y , q , remove )
```

Fungsi `dlm()` akan menerapkan model lag terdistribusi dengan satu atau lebih prediktor. Nilai `x` dan `y` tidak perlu sebagai objek *time series* (`ts`). $q$ adalah integer yang mewakili panjang *lag* yang terbatas.

## Pemodelan (Lag=2)

```{r}
# nilai q berarti memasukkan pengaruh Xt ke 2 lag pertama
model.dlm <- dlm(x = train$Xt,y = train$Yt , q = 2)
summary(model.dlm)
# Menghitung nilai AIC dan BIC untuk mengevaluasi kualitas model
AIC(model.dlm)
BIC(model.dlm)
```

Dari hasil diatas, didapat bahwa $P-value$ dari intercept dan $x_{t-1}<0.05$. Hal ini menunjukkan bahwa intercept dan $x_{t-1}$ berpengaruh signifikan terhadap $y$. Adapun model keseluruhan yang terbentuk adalah sebagai berikut

$$
\hat{Y_t}=35.453-8.438X_t+6.515X_{t-1}-2.178X_{t-2}
$$

## Peramalan dan Akurasi

Berikut merupakan hasil peramalan $y$ untuk 14 periode kedepan

```{r}
fore.dlm <- forecast(model = model.dlm, x=test$Xt, h=14)
fore.dlm
mape.dlm <- MAPE(fore.dlm$forecasts, test$Yt)
mape.dlm
#akurasi data training
GoF(model.dlm)
```

## *Lag* Optimum

```{r}
#penentuan lag optimum 
finiteDLMauto(formula = Yt ~ Xt,
              data = data.frame(train), q.min = 1, q.max = 10,
              model.type = "dlm", error.type = "AIC", trace = TRUE)
```

Berdasarkan output tersebut, lag optimum didapatkan ketika lag=10. Selanjutnya dilakukan pemodelan untuk lag=10

```{r}
#model dlm dengan lag optimum
model.dlm2 <- dlm(x = train$Xt,y = train$Yt , q = 10)
summary(model.dlm2)
AIC(model.dlm2)
BIC(model.dlm2)
```

Dari hasil tersebut terdapat beberapa peubah yang berpengaruh signifikan terhadap taraf nyata 5% yaitu $x_t$ , $x_{t-7}$ , $x_{t-10}$. Adapun keseluruhan model yang terbentuk adalah

$$
\hat{Y_t}=39.894-15.772X_t+...-4.613X_{t-10}
$$

Adapun hasil peramalan 14 periode kedepan menggunakan model tersebut adalah sebagai berikut

```{r}
#peramalan dan akurasi
fore.dlm2 <- forecast(model = model.dlm2, x=test$Xt, h=14)

#akurasi data test
mape.dlm2<- MAPE(fore.dlm2$forecasts, test$Yt)
mape.dlm2

#akurasi data training
GoF(model.dlm2)
```

Model tersebut merupakan model yang sangat baik dengan nilai MAPE yang kurang dari 10%.

# Model Autoregressive

Peubah dependen dipengaruhi oleh peubah independen pada waktu sekarang, serta dipengaruhi juga oleh peubah dependen itu sendiri pada satu waktu yang lalu maka model tersebut disebut *autoregressive* (Gujarati 2004).

## Pemodelan

Pemodelan Autoregressive dilakukan menggunakan fungsi `dLagM::ardlDlm()` . Fungsi tersebut akan menerapkan *autoregressive* berordo $(p,q)$ dengan satu prediktor. Fungsi umum dari `ardlDlm()` adalah sebagai berikut.

```{r, eval=FALSE, error=FALSE}
ardlDlm(formula = NULL , data = NULL , x = data$NULL , y = data$NULL , p = 1 , q = 1 , 
         remove = NULL )
```

Dengan $p$ adalah integer yang mewakili panjang *lag* yang terbatas dan $q$ adalah integer yang merepresentasikan ordo dari proses *autoregressive*.

```{r}
model.ardl <- ardlDlm(x = train$Xt, y = train$Yt, p = 1 , q = 1)
summary(model.ardl)
AIC(model.ardl)
BIC(model.ardl)
```

```{r}
model.ardl <- ardlDlm(formula = Yt ~ Xt, 
                         data = train,p = 1 , q = 1)
summary(model.ardl)
AIC(model.ardl)
BIC(model.ardl)
```

Hasil di atas menunjukkan bahwa selain peubah $Y_{t-1}$, hasil uji t menunjukkan nilai-p pada peubah $\ge0.05$ Hal ini menunjukkan bahwa peubah $Y_{t-1}$ berpengaruh signifikan terhadap $y_t$, sementara $x_t$ dan $_{t-1}$ tidak berpengaruh signifikan terhadap $y_t$. Model keseluruhannya adalah sebagai berikut:

$$
\hat{Y}=4.00535-0.52588X_t-0.03046X_{t-1}+0.89112Y_{t-1}
$$

## Peramalan dan Akurasi

```{r}
# h = 14 => jumlah periode ke depan yang akan diramalkan (14 periode)
fore.ardl <- forecast(model = model.ardl, x=test$Xt, h=14)
fore.ardl
```

Data di atas merupakan hasil peramalan untuk 5 periode ke depan menggunakan Model Autoregressive dengan $p=1$ dan $q=1$.

```{r}
# Mengukur akurasi model ARDL pada data tes
mape.ardl <- MAPE(fore.ardl$forecasts, test$Yt)
mape.ardl
#akurasi data training
GoF(model.ardl)
```

Berdasarkan akurasi di atas model regresi dengan distribusi lag ini tidak `overfitted` atau `underfitted`

## *Lag* Optimum

```{r}
#penentuan lag optimum
model.ardl.opt <- ardlBoundOrders(data = data.frame(data), ic = "AIC", 
                                  formula = Yt ~ Xt )
model.ardl.opt
min_p=c()

#Untuk mencari nilai AIC minimum pada setiap q
for(i in 1:10){
  min_p[i]=min(model.ardl.opt$Stat.table[[i]])
}

# Menentukan nilai q dan p optimum
q_opt=which(min_p==min(min_p, na.rm = TRUE))
p_opt=which(model.ardl.opt$Stat.table[[q_opt]] == 
              min(model.ardl.opt$Stat.table[[q_opt]], na.rm = TRUE))
data.frame("q_optimum" = q_opt, "p_optimum" = p_opt, 
           "AIC"=model.ardl.opt$min.Stat)
```

Dari tabel di atas, dapat terlihat bahwa nilai AIC terendah didapat ketika $p=15$ dan $q=5$, yaitu sebesar `124.7089`. Artinya, model autoregressive optimum didapat ketika $p=15$ dan $q=5$.

Selanjutnya dapat dilakukan pemodelan dengan nilai $p$ dan $q$ optimum seperti inisialisasi di langkah sebelumnya.

```{r}
model.ardl.opt <- ardlDlm(x = train$Xt, y = train$Yt, p = 15, q = 5)
summary(model.ardl.opt)
AIC(model.ardl.opt)
BIC(model.ardl.opt)
```

```{r}
model.ardl.opt <- ardlDlm(formula = Yt ~ Xt, 
                         data = train,p = 15 , q = 5)
summary(model.ardl.opt)
AIC(model.ardl.opt)
BIC(model.ardl.opt)
```
## Peramalan dan Akurasi Lag Optimum
```{r}
# Peramalan (Forecast) dengan model ARDL lag optimum dengan panjang periode = 14
fore.ardl.opt <- forecast(model = model.ardl.opt, x = test$Xt, h = 14)

fore.ardl.opt
```

```{r}
# Menghitung nilai akurasi peramalan pada data test
mape.ardl.opt <- MAPE(fore.ardl.opt$forecasts, test$Yt)
mape.ardl.opt
GoF(model.ardl.opt)
```

# Pemodelan DLM & ARDL dengan Library `dynlm`

Pemodelan regresi dengan peubah *lag* tidak hanya dapat dilakukan dengan fungsi pada *packages* `dLagM` , tetapi terdapat *packages* `dynlm` yang dapat digunakan. Fungsi `dynlm` secara umum adalah sebagai berikut.

```{r, eval=FALSE, Error=FALSE}
dynlm(formula, data, subset, weights, na.action, method = "qr",
  model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,
  contrasts = NULL, offset, start = NULL, end = NULL, ...)
```

Untuk menentukan `formula` model yang akan digunakan, tersedia fungsi tambahan yang memungkinkan spesifikasi dinamika (melalui `d()` dan `L()`) atau pola linier/siklus dengan mudah (melalui `trend()`, `season()`, dan `harmon()`). Semua fungsi formula baru mengharuskan argumennya berupa objek deret waktu (yaitu, `"ts"` atau `"zoo"`).

`L()` : fungsi untuk mengambil nilai lag dari suatu variabel.

`L(Xt)`= Xt pada periode sebelumnya (lag ke-1).

`L(Xt, 2)` = Xt pada dua periode sebelumnya (lag ke-2).

```{r}
#sama dengan model dlm q=1
cons_lm1 <- dynlm(Yt ~ Xt+L(Xt),data = train.ts)

#sama dengan model ardl p=1 q=0
cons_lm2 <- dynlm(Yt ~ Xt+L(Yt),data = train.ts)

#sama dengan ardl p=1 q=1
cons_lm3 <- dynlm(Yt ~ Xt+L(Xt)+L(Yt),data = train.ts)

#sama dengan dlm p=2
cons_lm4 <- dynlm(Yt ~ Xt+L(Xt)+L(Xt,2),data = train.ts)
```

## Ringkasan Model

Berikut adalah ringkasan hasil estimasi dari masing-masing model:

```{r}
summary(cons_lm1)
summary(cons_lm2)
summary(cons_lm3)
summary(cons_lm4)
```

## SSE

Selain ringkasan hasil, kita juga bisa menghitung nilai SSE dari masing-masing model.

```{r}
deviance(cons_lm1)
deviance(cons_lm2)
deviance(cons_lm3)
deviance(cons_lm4)
```

Semakin kecil nilai SSE, berarti model lebih baik dalam menyesuaikan data (karena error lebih kecil).

## Ui encomptest

langkah selanjutnya adalah membandingkan kinerja antar model. selanjutnya adalah membandingkan kinerja antar model. Salah satu pendekatan yang dapat digunakan adalah encompassing test dengan fungsi `encomptest()` dari package `lmtest`.

```{r}
#uji model
if(require("lmtest")) encomptest(cons_lm1, cons_lm2)
```

-   Model 1 : p-value 2e-16 (\< 0.001). Artinya, penambahan lag dari Y (`L(Yt)`) memberikan peningkatan signifikan.\
    Dengan demikian, Model 1 belum memadai.

-   Model 2 : p-value = 0.9568 (\> 0.05).\
    Artinya, penambahan lag dari X (`L(Xt)`) tidak memberikan peningkatan signifikan.Sehingga Model 2 cukup memadai.

### Uji Autokorelasi Residual

```{r}
#durbin watson
dwtest(cons_lm1)
dwtest(cons_lm2)
dwtest(cons_lm3)
dwtest(cons_lm4)
```

### Uji Heterogenitas

```{r}
bptest(cons_lm1)
bptest(cons_lm2)
bptest(cons_lm3)
bptest(cons_lm4)
```

-   Jika p-value \> 0.05 → tidak ada heteroskedastisitas

<!-- -->

-    Jika p-value ≤ 0.05 → ada heteroskedastisitas.

### Uji Normalitas

H0: Residual berdistribusi normal.

H1: Residual tidak berdistribusi normal.

```{r}
shapiro.test(residuals(cons_lm1))
shapiro.test(residuals(cons_lm2))
shapiro.test(residuals(cons_lm3))
shapiro.test(residuals(cons_lm4))
```

-   Jika p-value \> 0.05 → gagal tolak H0 → residual normal.

<!-- -->

-    Jika p-value ≤ 0.05 → tolak H0 → residual tidak normal.

# Perbandingan Model

Membuat tabel ringkas akurasi model berdasarkan nilai MAPE (Mean Absolute Percentage Error).

```{r}
akurasi <- matrix(c(mape.koyck, mape.dlm, mape.dlm2, mape.ardl))
row.names(akurasi)<- c("Koyck","DLM 1","DLM 2","Autoregressive")
colnames(akurasi) <- c("MAPE")
akurasi
```

Berdasarkan nilai MAPE, model paling optimum didapat pada Model Koyck karena memiliki nilai MAPE yang terkecil.

## Plot

Untuk membandingkan hasil peramalan dari berbagai model (Koyck, DLM 1, DLM 2, dan ARDL) dengan data aktual, dibuat grafik garis. Visualisasi ini membantu melihat seberapa dekat hasil ramalan tiap model dengan nilai aktual.

```{r}
str(test$Xt)
str(test$Yt)
str(fore.koyck$forecasts)
str(fore.dlm$forecasts)
str(fore.dlm2$forecasts)
str(fore.ardl$forecasts)
str(fore.ardl.opt$forecasts)

x <- 1:length(test$Xt)  # buat x = 1,2,3,...,7

plot(x, test$Yt, type="b", col="black",
     ylim=range(c(test$Yt, fore.koyck$forecasts,
                  fore.dlm$forecasts, fore.dlm2$forecasts,
                  fore.ardl$forecasts)))

lines(x, fore.koyck$forecasts, col="red", lwd=2)
lines(x, fore.dlm$forecasts, col="blue", lwd=2)
lines(x, fore.dlm2$forecasts, col="orange", lwd=2)
lines(x, fore.ardl$forecasts, col="green", lwd=2)
lines(x, fore.ardl.opt$forecasts, col="pink", lwd=2)

legend("topleft",
       c("Aktual", "Koyck","DLM 1","DLM 2", "Autoregressive", "Autoregressive Opt"),
       lty=1, col=c("black","red","blue","orange","green", "pink"), cex=0.8)
```

Berdasarkan plot perbandingan, terlihat bahwa semua model mampu mengikuti tren data aktual, meskipun dengan tingkat kedekatan yang berbeda. Secara keseluruhan, DLM 1 dan Koyck tampak paling konsisten dalam mengikuti pola aktual, sedangkan DLM 2 lebih berfluktuasi dan Autoregressive terlalu sederhana untuk menggambarkan dinamika data.