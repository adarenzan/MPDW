---
title: "Pertemuan 4"
author: "Mhd Haekal Hakim"
date: "2025-09-25"
output: html_document
---


## White Noise

*White noise* merupakan sederet nilai dari peubah bebas stokastik identik. Oleh karena itu, *white noise* memiliki dua karakteristik penting:

1.  Tidak memiliki autokorelasi (saling bebas)
2.  Nilai harapan dan ragam *white noise* sama

*White noise* dibangkitkan dari suatu peubah acak, umumnya peubah acak normal.

```{r warning=FALSE}
library(TSA)      # untuk eacf
library(stats) # untuk ARMAacf, acf, pacf
set.seed(012) # setseed berdasarkan NIM
wn <- rnorm(300) # jumlah data
ts.plot(wn)
```

```{r}
par(mfrow = c(1, 2)) 
acf(wn) #melihat nilai ACF
acf(wn, xlim = c(1, 20)) # Jika ingin lag 0 nya tidak kelihatan
```
Dapat terlihat bahwa *white noise* tidak memiliki autokorelasi dari Plot ACF. Lag ke-0  pasti bernilai 1. Sebagai alternatif, lag pertama di plot ACF dapat ditetapkan sebagai 1 (alih-alih 0) dengan menambahkan argumen `xlim(1, lag akhir)`. Plot tersebut dapat disandingkan bersamaan dengan membuat matriks $1 \times 2$ dengan `par(mfrow = c(1,2))`.

## Proses MA

Proses MA dapat dituliskan sebagai berikut:

$$
y_{t} = c + e_t + \theta_{1}e_{t-1} + \theta_{2}e_{t-2} + \dots + \theta_{q}e_{t-q} = c+{e_t+\sum_{i=1}^p \theta_ie_{t-i}}
$$

Terlihat bahwa $e_t$ (white noise), berperan penting dalam pembangkitan proses MA.

## Pembangkitan Proses MA(2)

Akan dicoba membangkitkan proses MA paling sederhana, yaitu MA(2) dengan $\theta = 0.4$ dan $\theta = 0.6$ sebanyak 300 observasi dan $c=0$. Karena diperlukan satu nilai awal untuk $e_{t-1}$, masukkan nilai pertama white noise sebagai nilai awal tersebut.

```{r}
set.seed(012)
ma <- wn[1]
```

Nilai-nilai selanjutnya dapat dicari melalui *loop*. Bentuk loop dapat dilihat dari rumus MA(2) yang hendak dibangkitkan:

$$
y_t = e_t+0.4e_{t-1}+0.6e_{t-2}
$$

```{r warning=FALSE}
for(i in 3:300){
   ma[i] <- wn[i] + 0.4 * wn[i - 1] + 0.6 * wn[i - 2]
}
ma
```

Selain menggunakan cara manual, juga bisa dengan fungsi `arima.sim()`

```{r}
ma2 <- arima.sim(list(order=c(0,0,2), ma= c(0.4, 0.6)), n=300) # Nilai lambda 0,4 dan 0,6
ma2
```

## Karakteristik MA(2)

### Plot Time Series

```{r}
ts.plot(ma)
```

Berdasarkan plot time series, terlihat bahwa data MA(2) yang dibangkitkan stasioner dalam rataan

### Plot ACF

```{r}
acf(na.omit(ma), lag.max = 20) #na.omit agar nilai N/A terhapus
```

Berdasarkan plot ACF tersebut, terlihat bahwa plot ACF *cuts off* di lag kedua

### Plot PACF

```{r}
pacf(na.omit(ma))
```

Berdasarkan plot PACF tersebut, terlihat bahwa plot PACF cenderung *tails off* dan membentuk gelombang sinus

### Plot EACF

```{r}
TSA::eacf(na.omit(ma))
```

Berdasarkan pola segitiga nol pada plot EACF yang ada, terlihat bahwa segitiga nol berada pada ordo AR(0) dan ordo MA(2)

### Scatterplot Antar Lag

#### Korelasi antara $Y_t$ dengan $Y_{t-1}$, $Y_t$ dengan $Y_{t-2}$, $Y_t$ dengan $Y_{t-3}$

```{r}
yt_ma   <- ma[4:300]   # Yt   = 4..300
yt_1_ma <- ma[3:299]   # Yt-1 = 3..299
yt_2_ma <- ma[2:298]   # Yt-2 = 2..298
yt_3_ma <- ma[1:297]   # Yt-3 = 1..297
```

```{r}
par(mfrow=c(1,3))
plot(y = yt_ma, x = yt_1_ma, main = "Yt vs Yt-1")
plot(y = yt_ma, x = yt_2_ma, main = "Yt vs Yt-2")
plot(y = yt_ma, x = yt_3_ma, main = "Yt vs Yt-3")
```

Berdasarkan scatterplot tersebut, terlihat bahwa terdapat hubungan positif antara $Y_t$ dengan $Y_{t-1}$ dan juga $Y_t$ dengan $Y_{t-2}$.untuk $Y_t$ dengan $Y_{t-3}$ polanya sudah mulai acak

```{r}
cor(yt_ma, yt_1_ma, use = "pairwise.complete.obs")  # lag 1
cor(yt_ma, yt_2_ma, use = "pairwise.complete.obs")  # lag 2
cor(yt_ma, yt_3_ma, use = "pairwise.complete.obs")  # lag 3
```
Terlihat bahwa, korelasi pada lag 2 lebih bagus dibandingkan dengan korealsi pada lag 1. Sedangkan untuk lag 3, itu korelasinya kecil dibandingkan dengan lag 1 dan lag 2

## Proses AR

Proses AR dapat dituliskan sebagai berikut:

$$ y_{t} = c + e_t + \phi_{1}Y_{t-1} + \phi_{2}Y_{t-2} + \dots + \phi_{q}Y_{t-q} = c+{e_t+\sum_{i=1}^p \phi_iY_{t-i}} $$ Terlihat bahwa $Y_t$ berperan penting dalam pembangkitan proses AR.

## Pembangkitan Proses AR

Akan dicoba membangkitkan proses AR paling sederhana, yaitu AR(2) dengan $\phi_1 = 0.5$ dan $\phi_2 = 0.2$ sebanyak 300 observasi dan $c=0$.

```{r}
set.seed(012)
```

Nilai-nilai selanjutnya dapat dicari melalui *loop*. Bentuk loop dapat dilihat dari rumus AR(2) yang hendak dibangkitkan:

$$ Y_t = e_t+0.5Y_{t-1}+0.2Y_{t-2} $$

```{r}
n<-length(wn)
n
ar <- c(1:n) 
for (i in 3:n) {ar[i]<-wn[i]+0.5*ar[i-1]+0.2*ar[i-2]}
ar
```

Selain menggunakan cara di atas, pembangkitan proses AR dapat dilakukan dengan fungsi `arima.sim()` sebagai berikut.

```{r}
ar2 <- arima.sim(list(order=c(2,0,0), ar=c(0.5,0.2)), n=300)
ar2
```

## Karakteristik AR(1)

### Plot Time Series

```{r}
ts.plot(ar)
```

Berdasarkan plot time series tersebut terlihat bahwa data cenderung stasioner pada rataan

### Plot ACF

```{r}
acf(ar)
```

Berdasarkan plot ACF tersebut terlihat bahwa plot ACF cenderung *tails off* dan cenderung membentuk pola grafik sinus

### Plot PACF

```{r}
pacf(ar)
```

Berdasarkan plot PACF tersebut, terlihat bahwa plot PACF *cuts off* pada lag kedua, sejalan dengan teori yang ada

### Plot EACF

```{r}
TSA::eacf(ar)
```

Berdasarkan pola segitiga nol pada plot EACF, terlihat bahwa segitiga nol berada pada ordo AR(1) dan ordo MA(1), atau bisa juga AR(2), dan ordo MA(2)

### Scatterplot Antar Lag

#### Korelasi antara $Y_t$ dengan $Y_{t-1}$, $Y_t$ dengan $Y_{t-2}$, dan $Y_t$ dengan $Y_{t-3}$

```{r}
yt_ar   <- ar[4:300]  # Yt
yt_1_ar <- ar[3:299]  # Yt-1
yt_2_ar <- ar[2:298]  # Yt-2
yt_3_ar <- ar[1:297]  # Yt-3
```

```{r}
# Plot Yt vs Yt-1
plot(yt_1_ar, yt_ar)
# Plot Yt vs Yt-2
plot(yt_2_ar, yt_ar)
# Plot Yt vs Yt-3
plot(yt_3_ar, yt_ar)
```

Berdasarkan scatterplot tersebut, terlihat bahwa terdapat hubungan positif antara $Y_t$ dengan $Y_{t-1}$, $Y_t$ dengan $Y_{t-2}$, dan $Y_t$ dengan $Y_{t-3}$.

```{r}
cor(yt_ar, yt_1_ar, use = "pairwise.complete.obs")
cor(yt_ar, yt_2_ar, use = "pairwise.complete.obs")
cor(yt_ar, yt_3_ar, use = "pairwise.complete.obs")
```

Korelasi antara $Y_t$ dengan $Y_{t-1}$, $Y_t$ dengan $Y_{t-2}$, dan $Y_t$ dengan $Y_{t-3}$ . Semakin tinggi lagnya, maka nilai koeralasinya semakin rendah

## Fungsi pembangkitan ARMA

Setelah mengetahui cara membangkitkan data berpola AR, MA, dan ARMA sederhana, bagaimana cara melakukan pembangkitan data berpola tersebut yang lebih kompleks? Apakah dapat dibuat suatu fungsi yang fleksibel yang memungkinan pembangkitan dengan berapapun jumlah koefisien?

Pertama, lihat kembali bentuk umum data berpola ARMA.

$$
y_{t} = c + \sum_{i=1}^p \phi_{i}y_{t-i} + \sum_{j=1}^q e_{t-j}+ e_{t}
$$

Komponen $c$ dan $e_{t}$ cukup mudah untuk dibuat dan dicari. Bagaimana untuk komponen AR dan MA? Bayangkan ada koefisien dan data sebagai berikut:

$$
\begin{aligned}
\begin{bmatrix}
\phi_1 \  \phi_2 \
\end{bmatrix}&=
\begin{bmatrix}
0.5 \ 0.2
\end{bmatrix}
\\
\begin{bmatrix}
y_{t-1} \  y_{t-2}
\end{bmatrix}&=
\begin{bmatrix}
1 \ 2
\end{bmatrix}
\end{aligned}
$$

Maka dari itu,

$$
\begin{aligned}
\begin{bmatrix}
\phi_1 \  \phi_2 \
\end{bmatrix}
\begin{bmatrix}
y_{t-1} \\  y_{t-2} \
\end{bmatrix} &= \phi_1 \ y_{t-1}+\phi_2 \ y_{t-2}
\\
\begin{bmatrix}
 0.5 \ 0.2
\end{bmatrix}
\begin{bmatrix}
1 \\ 2 \
\end{bmatrix} & = 0.5 \cdot1+0.2 \cdot 2
=0.5+1+0.4 = 0.9
\end{aligned}
$$

Jika koefisien dan *white noise*/nilai deret waktu sebelumnya dapat diekstrak dalam bentuk vektor, dapat dilakukan perkalian matriks untuk mencari nilai bagian AR dan MA:

```{r}
set.seed(300)
coefs <- c(0.5, 0.2)  # AR(2)
e <- c(1, 2)           # y_{t-1}, y_{t-2}
coefs %*% e
```

Atau, dapat dilakukan perkalian *elementwise* yang dijumlahkan:

```{r}
coefs * e
sum(coefs * e)
```

Dari prinsip ini, dapat dibuat fungsi umum untuk membangkitkan data ARMA. Input dari fungsi adalah jumlah data yang hendak dibangkitkan, koefisien MA, dan koefisien AR

```{r}
arma.sim <- function(n, macoef, arcoef){
  manum <- length(macoef)
  arnum <- length(arcoef)
  stopifnot(manum < n & arnum < n)
  
  wn <- rnorm(n, sd = 0.5)
  init <- max(manum, arnum)

  arma <- wn[1:init]
  for(i in {init+1}:n){
   mastart <- i - manum
   maend <- i-1
   arstart <- i - arnum
   arend <- i-1
   arma[i] <- sum(arcoef * arma[arstart:arend]) + sum(macoef * wn[mastart:maend])  + wn[i]
   }
  return(arma)
}
```

Terlihat bahwa komponen $\sum_{i=1}^q y_{t-1}$ disimulasikan melalui `sum(arcoef * arma[arstart:arend])`. Jadi, koefisien dikalikan dengan data $y$ dari $t-q$ di mana q adalah jumlah koefisien AR, sampai data $t-1$. Lalu komponen $\sum_{j=1}^q e_{t-j}$ disimulasikan melalui `sum(macoef * wn[mastart:maend])`. Koefisien dikalikan dengan *white noise* $e$ dari $t-p$, p jumlah koefisien MA, sampai $t-1$.

```{r}
# beberapa contoh pembangkitan melalui fungsi
set.seed(012)
ma2 <- arma.sim(300, macoef = c(0.4, 0.6), arcoef = 0)
ar2 <- arma.sim(300, macoef = 0, arcoef = c(0.5, 0.2))

par(mfrow = c(2, 2))
acf(ma2)
pacf(ma2)
acf(ar2)
pacf(ar2)
```

```{r}
#contoh untuk ARMA
arma22 <- arma.sim(300, macoef = c(0.4, 0.6), arcoef = c(0.5, 0.2))

arma22 |> arima(c(2,0,2))
```

```{r}
set.seed(012)
n = length(wn)  
phi1 = 0.5      # AR1
phi2 = 0.2      # AR2
theta1 = 0.4    # MA1
theta2 = 0.6    # MA2

y.arma = c(1:n)
for (i in 3:n){
  y.arma[i] = phi1*y.arma[i-1] + phi2*y.arma[i-2] + theta1*wn[i-1] + theta2*wn[i-2] + wn[i]
}
y.arma
```

Pembangkitan ARMA(p,q) juga dapat dilakukan dengan fungsi `arima.sim` sebagai berikut.

```{r}
arma22 <- arima.sim(list(order=c(2,0,2), ar = c(0.5,0.2), ma = c(0.4,0.6)), n=300)
arma22
```

## Karakteristik ARMA(1,1)

### Plot Time Series

```{r}
par(mfrow = c(1, 2))
ts.plot(y.arma)   # versi manual loop ARMA(2,2)
ts.plot(arma22)   # versi arima.sim ARMA(2,2)
par(mfrow = c(1, 1))
```

Berdasarkan plot time series tersebut, terlihat bahwa model ARMA(2,2) cenderung stasioner dalam rataan

### Plot ACF

```{r}
par(mfrow = c(1, 2))
acf(y.arma)    # versi manual loop ARMA(2,2)
acf(arma22)    # versi arima.sim ARMA(2,2)
par(mfrow = c(1, 1))
```

Berdasarkan plot ACF tersebut, terlihat bahwa model ARMA(2,2) hasil simulasi memiliki plot ACF yang *tails off*, sesuai dengan teori yang ada

### Plot PACF

```{r}
par(mfrow = c(1, 2))
pacf(y.arma)    # versi manual loop ARMA(2,2)
pacf(arma22)    # versi arima.sim ARMA(2,2)
par(mfrow = c(1, 1))
```

Berdasarkan plot PACF tersebut, terlihat bahwa model ARMA(2,2) hasil simulasi memiliki plot PACF yang *tails off*, sesuai dengan teori

### Plot EACF

```{r}
TSA::eacf(y.arma)
TSA::eacf(arma22)
```

### Scatterplot Antar Lag

#### Korelasi antara $Y_t$ dengan $Y_{t-1}$, $Y_t$ dengan $Y_{t-2}$, dan $Y_t$ dengan $Y_{t-3}$

```{r}
# Yt
yt_arma <- arma22[-c(1:3)]
# Yt-1
yt_1_arma <- arma22[-c(300,299,298)]
# Yt-2
yt_2_arma <- arma22[-c(1,300,299)]
# Yt-3
yt_3_arma <- arma22[-c(1,2,300)]
```

```{r}
par(mfrow = c(1, 3))
plot(y = yt_arma, x = yt_1_arma)  # Yt vs Yt-1
plot(y = yt_arma, x = yt_2_arma)  # Yt vs Yt-2
plot(y = yt_arma, x = yt_3_arma)  # Yt vs Yt-3
```
Data $y_t$ punya autokorelasi yang cukup kuat di lag-2 dan lag-3, sedangkan di lag-1 agak lemah.
 
```{r}
# Korelasi Yt vs lag 1â€“3
cor(yt_arma, yt_1_arma)  # Yt vs Yt-1
cor(yt_arma, yt_2_arma)  # Yt vs Yt-2
cor(yt_arma, yt_3_arma)  # Yt vs Yt-3
```
Pola autokorelasi naik dari lag-1 ke lag-3